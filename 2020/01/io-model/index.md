# 五种IO模型


## 1.用户空间和内核空间

现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。``操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。``为了保证用户进程不能直接操作内核，从而保护内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。``内核空间中存放的是内核代码和数据，用户空间存放的是用户的应用程序代码和数据。``

当用户的应用程序需要执行一个系统调用的时候，就需要从用户态切换到内核态，最后在切换到用户态。例如一次文件读取，就需要经过以下几个步骤：

1. 应用程序发起IO请求，操作系统从用户态切换到内核态。
2. 从磁盘拷贝数据到内核空间。
3. 再将内核空间的数据拷贝到用户空间，同时切换回用户态。
4. 应用程序读取用户空间的数据。

在应用进程发起IO调用到系统返回这段时间，进程是阻塞的。所以为了优化性能，就诞生了多种不同的IO模型。



## 2.同步和异步，阻塞和非阻塞

在介绍IO模型前，我们一定要先搞定同步/异步和阻塞/非阻塞的区别。我们拿买东西为例介绍这两个概念。假设我想买一台ipad，我可以直接亲自去苹果体验中心购买也可以在淘宝上下单让人给我送过来。在这个例子中，我亲自去购买，这个就是同步，而通过淘宝下单让快递员送到我手中这就是异步。同步和异步的主要区别就是在这个动作执行的实体是谁，把ipad从店里拿到我手中这动作，同步就是我亲自去，异步就是由快递员去帮我完成。

假设我去了苹果体验中心需要排队购买，在等待的过程中我可以选择静静的等待啥也不做，也可以选择边玩手机边等。在这个例子中，静静的等待啥也不做就是阻塞的，而边玩手机边等就是非阻塞的。阻塞和非阻塞的区别主要就在于等待动作完成的过程中，进程是否可以去干别的事情。



## 3.阻塞式IO(blocking I/O)

生活场景：小钟去苹果体验中心购买ipad，被导购员告知需要排队等待购买，于是小钟就傻傻的在队伍中等待。

同步阻塞IO是最常用的一个模型也是最简单的模型。在这个模型中当应用程序发起一个系统调用(recvfrom)，导致应用程序阻塞，什么也干不了，直到内核将数据准备好并拷贝到用户进程，最后进程再处理数据。在等待数据和处理数据这两个阶段，整个进程一直处于阻塞状态，不能处理别的网络IO。

![阻塞IO.png](https://i.loli.net/2020/01/19/RgltDOdLP5npY4A.png)

## 4.同步非阻塞IO(noblocking I/O)

生活场景：小钟觉得等待的太无聊，于是就在店内逛逛看看其他产品，时不时的去问一下导购员轮到他了没。

同步非阻塞IO模型以轮询方式询问内核数据是否准备好。这意味IO操作不会立即完成，read操作可能会返回错误代码告知这个命令不能立即满足。进程接收到返回后可以去干点别的事情，然后再次询问。长此以往，直到内核将数据准备好再拷贝到用户进程。``需要注意，在拷贝到进程的过程中，进程仍是处于阻塞状态。``

![同步非阻塞.png](https://i.loli.net/2020/01/19/GFVBgtceLOUDq1k.png)

## 5.IO多路复用(I/O multiplexing)

生活场景：导购员觉得所有人都来不停的问他太烦了，于是在墙上装了一块电子屏，显示排队状态。这样所有人都可以通过观察电子屏来了解是否轮到自己，就用直接去问导购员了。

IO多路复用和同步非阻塞IO的主要区别在于，同步非阻塞IO会不断的主动轮询，这会非常消耗CPU资源。而后台可能会有多个进程执行了系统调用，这样就可以循环检查每个进程任务的状态，只要有任何一个任务处于完成状态，就去处理它。而这个轮询的动作是可以交给“别人”来做的，不需要调用进程本身。

IO多路复用可以同时监听多个socket，只要其中任何一个socket有数据到达，进程就可以读取它。当然这个过程也是阻塞的，但它与阻塞IO不同的是，它不需要等到所有的数据到达处理，而是有一部分就处理一部分。这个是否有数据到达，是由内核来监视的。

![IO多路复用.png](https://i.loli.net/2020/01/19/uigaUHp6QeOlz5n.png)

## 6.信号驱动IO(signal driven I/O)

生活场景：导购员给每个人发了一个唯一的编号，告诉大家可以随意在店内逛逛，等到了谁他会叫号的。

信号驱动IO会给进程添加一个信号处理函数，然后进程可以去做其它事情不会阻塞，当内核数据准备好时会发送一个信号给进程，进程收到信号后可以在信号处理函数中调用IO操作函数处理数据。

![信号驱动IO.png](https://i.loli.net/2020/01/19/8ORCia2kVMPo9lA.png)

## 7.异步IO(asynchronous IO)

生活场景：等了很久都还没有到小钟，小钟不想再等了，想回家写代码。于是小钟就回家了，然后京东上买了一台ipad，第二天京东就给送到了。

异步IO在用户进程执行了系统调用后，无论内核是否准备好数据都会立即返回。然后用户进程可以去做其他事情。等到数据准备好，内核直接拷贝给用户进程，然后内核向用户进程发送通知。``在这里，数据的准备和拷贝两个阶段，用户进程都是非阻塞的。因为在拷贝数据时，不是用户进程来取，而是内核主动给。``

![异步IO.png](https://i.loli.net/2020/01/19/n7IaOjhCgidUcwz.png)

## 8.五种IO模型总结

同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO都属于同步IO，只有异步IO属于异步。同步和异步的主要差别体现在当内核数据准备好后，同步IO需要进程自己去取，这个过程中进程依旧是阻塞的。而异步IO则是内核直接将数据拷贝给进程，不需要进程自己主动拷贝，可以直接使用，这个过程进程是非阻塞的。

IO多路复用和同步非阻塞IO十分相似，但是同步非阻塞IO一直轮询内核数据是否准备好，这是十分耗费cpu资源的。而IO多路复用是将多个socket注册到select函数。select可以同时监视多个socket的状态，只要任何一个socket有数据到达就会去处理它，``注意不是等到所有，而是只要有一部分。``