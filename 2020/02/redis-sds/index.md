# SDS


## 1.何为SDS

redis使用一种名为简单动态字符串(simple dynamic string，简称SDS)的抽象类型，并将SDS用作redis的默认字符串表示。

在redis中，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，例如打印日志。当redis需要的不仅仅是一个字符串字面量，而是一个可以修改的字符串值时，redis就会使用SDS来表示字符串值。

举个栗子，在客户端执行命令：``set msg "hello world"``

那么redis将创建一个新的键值对，其中：

- `键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg"的SDS。`
- `键值对的值也是一个字符串对象，对象底层实现是一个保持着字符串“hello world"的SDS。`

又例如，在客户端执行：``rpush fruits "apple" "banana" "cherry"``

那么redis将创建一个新的键值对，其中：

- `键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"fruits"的SDS。`
- `键值对的值是一个列表对象，包含了3个SDS实现的字符串对象，第一个"apple"，第二个"banana"，第三个“cheery”。`

每个sds.h/sdshdr结构表示一个SDS

```java
struct sdshdr {
    // 记录buf数组中已使用的字节数，等于SDS所保存的字符串长度
    int len;
    // 记录buf数组中未使用的字节数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

![image.png](https://i.loli.net/2020/02/17/3RFdXhWkQLHf15l.png)

上图是一个sds的结构，它表示一个字符串"Redis"。其中free=0，代表这个SDS没有任何未使用空间，len=5表示这个SDS保存了一个5字节长度的字符串。buf是一个char类型的数组，数组的最后一个字节保存了空字符'\0'。SDS遵循C字符串以空字符结尾的惯例，但保存空字符的1字节空间不计算在SDS的len属性里。SDS遵循这一惯例是为了直接重用一部分C字符串函数库的函数。



## 2.SDS的好处

### 2.1 常数复杂度获取字符串长度

像C这样直接使用字节数组来保存字符串，获取字符串长度时要依次遍历每个字符直到遇到空字符为止，这个操作的时间复杂度为0(N)。

而对于SDS来说，直接获取len属性就可以了。时间复杂度为O(1)。

### 2.2 杜绝缓冲区溢出

C字符串不记录自身长度，可能会造成缓冲区溢出。比如这个函数：``char *stract(char *dest, const char *src)``，将src拼接到dest的末尾。stract会假设用户已经为dest分配了足够多的内存，而一旦这个假设不成立，就会产生缓冲区溢出。

而SDS完全杜绝了这种可能，当对SDS修改时，SDS会先检查空间是否满足需要，如果空间不够，SDS会自动将空间扩展至执行修改所需的大小，然后才执行修改操作。

![image.png](https://i.loli.net/2020/02/17/3RFdXhWkQLHf15l.png)

例如我们对上图的SDS执行函数：``sdcat(s," Clustser")``。s为SDS的值。

那么sdscat在执行拼接操作前，会先检查s的长度是否足够，在发现s目前的空间不足以拼接"&nbsp;&nbsp;Cluster"后，sdcat就会先扩展s的空间，然后再执行"&nbsp;&nbsp;Cluster"的拼接操作。	

![image.png](https://i.loli.net/2020/02/17/wtmn1fRjsgz3HqG.png)

注意，sdscat不仅执行了拼接操作，还未SDS分配了13字节的未使用空间。这可不是巧合，而是一种策略。下面来说明这种策略的好处

### 2.3 减少修改字符串时带来的内存重分配次数

在对C字符串做修改时，如果追加字符则需要通过内存重分配来拓展内存空间，如果截取字符则需要通过内存重分配来释放内存。但是对于redis这种要求速度快，数据频繁修改的场合，如果每次修改都要一次内存重分配，那么对性能带来损耗是不能接受的。

为了避免这种缺陷，SDS通过空间预分配和惰性空间释放两种策略来优化。

空间预分配：当对SDS的字符串做增长操作，并且需要对SDS进行空间预分配时，程序不仅会为SDS分配修改所必要的空间，还会为SDS分配额外的未使用空间。

- 如果SDS的len属性小于1MB，那么将分配和len属性同样大小的未使用空间，这时SDS的len属性值和free属性值相同。举个例子，如果修改后SDS的len变成13字节，那么程序也会分配13字节的未使用空间，那么SDS的buf数组实际长度将变成``13+13+1=27字节(额外的一字节用于保存空字符)``。

- 如果SDS的len属性大于1MB。那么程序将分配1MB的未使用空间。例如，修改后，SDS的len变成2MB，那么程序会分配1MB的未使用空间，SDS的buf数组实际长度将变成``2MB+1MB+1byte``

  

通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存分配次数

![image.png](https://i.loli.net/2020/02/17/3RFdXhWkQLHf15l.png)

例如我们对上面的SDS执行：``sdcat(s," Clustser")``；那么sdcat将执行一次内存重分配操作，将SDS长度修改为13字节，并将SDS的未使用空间同样修改为13字节，如下图所示。

![image.png](https://i.loli.net/2020/02/17/wtmn1fRjsgz3HqG.png)

如果这时，我们再次执行：``sdcat(s," Tutorial")``；那么这次sdscat将不需要执行内存重分配，因为未使用空间的13字节足以保存9字节的“&nbsp;&nbsp;Tutorial”，执行后SDS如下图所示

![image.png](https://i.loli.net/2020/02/17/ft7EYksBoH2aj9Q.png)

惰性空间释放：当对SDS字符串做缩短操作时，程序并不会立即使用内存重分配来回收缩短后多余的字节空间。而是用free属性将这些字节记录下来，供后续使用。

我们也不必担心惰性空间释放策略会造成内存浪费，SDS提供了相应的API，让我们可以在有需要时释放SDS的未使用空间。

### 2.4 二进制安全

C字符串中要求除了以空字符结尾，字符串中不能含有空字符。否则最先被读入的空字符会被误以为是字符串的结尾。这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。为了确保redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。

所以我们称SDS的buf属性为字节数组，因为它不是来保存字符，而是保存一系列二进制数据。

